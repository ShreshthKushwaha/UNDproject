from flask import Flask, request, jsonify,url_for,request
import mysql.connector
import sqlalchemy

app = Flask(__name__)

# Connecting to MySQL server
conn = mysql.connector.connect(
    host='localhost',
    user='root',
    password='Shreshth@2023',
    database='social_media'
)

def execute_query(query, args=None):
    conn.reconnect()
    cursor = conn.cursor()
    cursor.execute(query, args)
    
    # Fetch column names
    column_names = [i[0] for i in cursor.description]
    
    # Fetch data rows
    rows = cursor.fetchall()
    
    # Combine column names with data rows
    results = [dict(zip(column_names, row)) for row in rows]
    
    conn.close()
    return results


@app.route('/search', methods=['GET'])
def search_posts():
    begin_date = request.args.get('begin_date')
    end_date = request.args.get('end_date')
    search_term = request.args.get('search_term')

    try:
        
        sqlalchemy.text(search_term)
    except sqlalchemy.exc.StatementError:
        return jsonify("Search term contains potentially malicious SQL code.")
    
    query = """
        SELECT * FROM post
        WHERE date BETWEEN %s AND %s
        AND message LIKE %s
    """
    args = (begin_date, end_date, f'%{search_term}%')
    results = execute_query(query, args)
    
    return jsonify(results)

@app.route('/tag_stats', methods=['GET'])
def tag_stats():
    query = """
        SELECT tag.name, COUNT(*) as post_count
        FROM tag
        INNER JOIN post_tags ON tag.id = post_tags.tag_id
        GROUP BY tag.name
    """
    results = execute_query(query)
    
    return jsonify(results)

@app.route('/top_posts', methods=['GET'])
def top_posts():
    begin_date = request.args.get('begin_date')
    end_date = request.args.get('end_date')
    ##query to ignore day but just list all the top posts in a month
    query = """
        SELECT *
            FROM (
                SELECT *,
                    (reposts / 10 + likes / 15) AS score,
                    ROW_NUMBER() OVER (PARTITION BY DATE_FORMAT(date, '%Y-%m') ORDER BY (reposts / 10 + likes / 15) DESC) AS r
                FROM post
                WHERE YEAR(date) * 100 + MONTH(date) BETWEEN YEAR(%s) * 100 + MONTH(%s) AND YEAR(%s) * 100 + MONTH(%s)
            ) AS ranked_posts
            WHERE r <= 3
            ORDER BY DATE_FORMAT(date, '%Y-%m'), score DESC
    """
    args = (begin_date, begin_date, end_date, end_date)  # Pass begin_date and end_date twice
    results = execute_query(query, args)
    
    return jsonify(results)


def has_no_empty_params(rule):
    defaults = rule.defaults if rule.defaults is not None else ()
    arguments = rule.arguments if rule.arguments is not None else ()
    return len(defaults) >= len(arguments)


@app.route("/")
def site_map():
    links = ["These are the endpoints available. Use them with required parameters to get the desired results via postman or any application",]
    for rule in app.url_map.iter_rules():
        # Filter out rules we can't navigate to in a browser
        # and rules that require parameters
        if "GET" in rule.methods and has_no_empty_params(rule):
            url = url_for(rule.endpoint, **(rule.defaults or {}))
            links.append((request.host_url[0:-1]+url))
    return jsonify(links)        
    # links is now a list of url, endpoint tuples

if __name__ == '__main__':
    app.run(debug=True)