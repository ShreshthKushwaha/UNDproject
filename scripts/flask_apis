from flask import Flask, request, jsonify,url_for,request
import mysql.connector
import sqlalchemy
from datetime import datetime
import time

app = Flask(__name__)

# Dictionary to store the last request time for each IP address
last_request_time = {}


# Rate limiter middleware
@app.before_request
def limit_request_rate():
    ip_address = request.remote_addr
    current_time = time.time()
    rate_limit = 2  # 2 requests per second

    # Check if the IP address has made a request before
    if ip_address in last_request_time:
        last_time = last_request_time[ip_address]
        # Check if less than 1 second has passed since the last request
        if current_time - last_time < 1/rate_limit:
            # Return a response indicating that the request is too frequent
            return jsonify({"error": "Too many requests. Please wait a moment before trying again."}), 429

    # Update the last request time for the IP address
    last_request_time[ip_address] = current_time

# Connecting to MySQL server
conn = mysql.connector.connect(
    host='localhost',
    user='root',
    password='Shreshth@2023',
    database='social_media'
)

def validate_date_format(date_str):
    try:
        datetime.strptime(date_str, '%Y-%m-%d')
        return True
    except ValueError:
        return False
    
def validate_date_range(begin_date, end_date):
    begin_date_obj = datetime.strptime(begin_date, '%Y-%m-%d')
    end_date_obj = datetime.strptime(end_date, '%Y-%m-%d')

    # Validate begin_date is smaller than or equal to end_date
    if begin_date_obj > end_date_obj:
        return False
    return True    

def validate(begin_date, end_date):
    if not validate_date_format(begin_date) or not validate_date_format(end_date):
        return False, "Invalid date format. Use 'YYYY-MM-DD' format."
    
    if not validate_date_range(begin_date, end_date):
        return False, "begin_date should be smaller than or equal to end_date."
    
    return True, None
    
def execute_query(query, args=None):
    conn.reconnect()
    cursor = conn.cursor()
    cursor.execute(query, args)
    
    # Fetch column names
    column_names = [i[0] for i in cursor.description]
    
    # Fetch data rows
    rows = cursor.fetchall()
    
    # Combine column names with data rows
    results = [dict(zip(column_names, row)) for row in rows]
    
    conn.close()
    return results


@app.route('/search', methods=['GET'])
def search_posts():
    begin_date = request.args.get('begin_date')
    end_date = request.args.get('end_date')
    valid_result=validate(begin_date, end_date)
    if valid_result[0]==False:
        return jsonify(valid_result[1])


    search_term = request.args.get('search_term')

    try:
        
        sqlalchemy.text(search_term)
    except sqlalchemy.exc.StatementError:
        return jsonify("Search term contains potentially malicious SQL code.")
    
    query = """
        SELECT * FROM post
        WHERE DATE(date) BETWEEN %s AND %s
        AND message LIKE %s
        order by date asc
    """
    args = (begin_date, end_date, f'%{search_term}%')
    results = execute_query(query, args)
    
    return jsonify(results)

@app.route('/tag_stats', methods=['GET'])
def tag_stats():
    query = """
        SELECT tag.name, COUNT(*) as post_count
        FROM tag
        INNER JOIN post_tags ON tag.id = post_tags.tag_id
        GROUP BY tag.name
    """
    results = execute_query(query)
    
    return jsonify(results)

@app.route('/top_posts', methods=['GET'])
def top_posts():
    begin_date = request.args.get('begin_date')
    end_date = request.args.get('end_date')
    valid_result=validate(begin_date, end_date)
    if valid_result[0]==False:
        return jsonify(valid_result[1])
    ##query to ignore day but just list all the top posts in a month
    query = """
        SELECT *
            FROM (
                SELECT *,
                    (reposts / 10 + likes / 15) AS score,
                    ROW_NUMBER() OVER (PARTITION BY DATE_FORMAT(date, '%Y-%m') ORDER BY (reposts / 10 + likes / 15) DESC, date ASC) AS r
                FROM post
                WHERE YEAR(date) * 100 + MONTH(date) BETWEEN YEAR(%s) * 100 + MONTH(%s) AND YEAR(%s) * 100 + MONTH(%s)
            ) AS ranked_posts
            WHERE r <= 3
            ORDER BY DATE_FORMAT(date, '%Y-%m'), score DESC
    """
    args = (begin_date, begin_date, end_date, end_date)  # Pass begin_date and end_date twice
    results = execute_query(query, args)
    
    return jsonify(results)


def has_no_empty_params(rule):
    defaults = rule.defaults if rule.defaults is not None else ()
    arguments = rule.arguments if rule.arguments is not None else ()
    return len(defaults) >= len(arguments)


@app.route("/")
def site_map():
    links = ["These are the endpoints available. Use them with required parameters to get the desired results via postman or any application",]
    for rule in app.url_map.iter_rules():
        # Filter out rules we can't navigate to in a browser
        # and rules that require parameters
        if "GET" in rule.methods and has_no_empty_params(rule):
            url = url_for(rule.endpoint, **(rule.defaults or {}))
            links.append((request.host_url[0:-1]+url))
    return jsonify(links)        
    # links is now a list of url, endpoint tuples

if __name__ == '__main__':
    app.run(debug=True)